Cypress End-to-End Testing Guide
Introduction to End-to-End Testing with Cypress
End-to-end (E2E) tests simulate real user workflows by testing an application from start to finish. They ensure that all parts of a web app (UI, backend, APIs, etc.) work together correctly in a production-like scenario​
BROWSERSTACK.COM
​
BROWSERSTACK.COM
. Cypress is a modern, open-source E2E testing framework built for web applications. We use Cypress because it runs tests directly in the browser (without needing Selenium/WebDriver), offering fast, reliable, and consistent test execution with real-time interaction and debugging capabilities​
BROWSERSTACK.COM
​
BROWSERSTACK.COM
. In other words, Cypress allows developers and QA engineers to write tests that mimic an end-user’s actions, providing immediate feedback and rich tools (like screenshots, videos, and dev tools access) for analyzing test behavior. How Cypress Fits in the Testing Stack: In a typical testing pyramid, unit tests cover individual functions/components, integration tests cover interactions between modules, and E2E tests cover user journeys through the fully integrated application. Cypress falls at the top of this pyramid by validating full application flows from the UI perspective, complementing lower-level tests. While unit tests ensure individual pieces work in isolation, E2E tests with Cypress verify that all pieces work together as expected for the user (e.g. form entry to database save to UI update). Using Cypress for E2E helps catch issues that only surface when the entire stack is exercised. It’s common to use Cypress alongside other testing tools – for example, to have fast unit tests for logic and use Cypress tests to verify critical user paths and regressions in the real app environment.
Project Setup Assumptions
This guide assumes that Cypress is already installed and initialized in your project. In practice, that means you have a cypress.config.{js/ts} configuration file and a cypress/ directory (with subfolders for test spec files, fixtures, and support code) generated by running npx cypress open or a similar setup. We will not cover installation steps, but briefly note the default Cypress structure:
text
Copy
Edit
Your Project/
├── cypress.config.js         # Cypress configuration (defines baseUrl, test file patterns, etc.)
└── cypress/
    ├── e2e/                  # Folder for all end-to-end test spec files
    │   ├── example.cy.js     # Example test spec (scaffolded by Cypress)
    │   └── ... your test files ...
    ├── fixtures/             # Static test data (JSON, images, etc.)
    │   └── example.json      # Example fixture
    └── support/              # Support files (reusable commands, hooks)
        ├── e2e.js            # Runs before every spec file (global setup)
        └── commands.js       # Custom commands defined via Cypress.Commands
By default, Cypress will place spec files in the cypress/e2e directory (with a .cy.js or .spec.js extension)​
DOCS.CYPRESS.IO
. Fixtures (static test data used in tests) live in cypress/fixtures​
DOCS.CYPRESS.IO
, and you can define shared behaviors or custom commands in cypress/support files. Cypress also automatically creates folders for screenshots and videos of test runs (usually cypress/screenshots/ and cypress/videos/), which you might want to add to .gitignore to avoid checking in large or sensitive files​
DOCS.CYPRESS.IO
​
DOCS.CYPRESS.IO
.
Note: We assume the application under test is a basic web app (HTML, CSS, JS) served locally (e.g. via http://localhost:PORT). Ensure your app can be accessed during testing. In CI environments, you might need to start a local server before running Cypress tests.
Guidelines for Writing Effective E2E Tests
This section provides guidelines and best practices for creating maintainable Cypress E2E tests. Following these conventions will make tests clear, robust, and easier to maintain (for both humans and AI agents processing the tests).
Test Naming Conventions
Descriptive Test Names: Use clear, descriptive names for test suites and test cases. This makes it immediately obvious what scenario is being tested. For example:
Suites (describe blocks): name them after the feature or page under test (e.g. "Login Page" or "User Profile Settings").
Tests (it blocks): describe the expected behavior or outcome in a sentence. It's common to phrase these as an outcome of a user action. For example:
js
Copy
Edit
describe('Login Page', () => {
  it('should log in successfully with valid credentials', () => { /* ... */ });
  it('shows an error message for invalid credentials', () => { /* ... */ });
});
Both tests clearly state what they expect (successful login vs. error on invalid login).
Avoid generic names like "test1" or "click login button" – these do not convey purpose​
MEDIUM.COM
. A good practice is to include the user’s perspective or goal in the test name. For instance, instead of "submit form test", use something like "should display a thank-you message after submitting the contact form". File Naming: Name spec files after the feature or page they test, using a consistent suffix. Cypress defaults to .cy.js (or .cy.ts) for spec files. For example, tests for the login functionality might reside in cypress/e2e/login.cy.js. Use lower-case and hyphens or camelCase consistently (e.g. user-profile.cy.js or userProfile.cy.ts). Including .cy or .spec in the filename helps distinguish test files from source code. Grouping related tests in subfolders (e.g. e2e/auth/login.cy.js) can further organize the suite by feature area. Structure Within Test Files: Use describe to group test cases logically. If a suite has multiple contexts or state variations, you can nest context or additional describe blocks. For example, you might have a top-level describe('User Profile') and inside it a context('when user is admin') vs context('when user is guest') to group tests under different conditions. (Using context is equivalent to describe – it’s mainly for readability.) If using context, some teams prefix it with keywords like "given" or "when" to describe preconditions, but this is optional. The key is to ensure each test’s purpose is clear from its description. Avoid Overly Long Titles: While descriptions should be clear, they should not be essays. Aim for concise clarity. If additional explanation is needed, consider adding comments inside the test rather than extremely long titles.
Folder and File Structure
Keep a well-organized test directory so tests are easy to find and maintain. The default structure is usually sufficient for small projects, but as your suite grows, consider organizing by feature or test type:
Feature-based structure: Group tests by application feature or page. For example:
bash
Copy
Edit
cypress/e2e/
  ├── auth/
  │    ├── login.cy.js
  │    └── registration.cy.js
  ├── dashboard/
  │    └── dashboard.cy.js
  └── settings/
       └── profile.cy.js
Each subfolder contains tests related to that area of the app.
Alternative structures: Some projects separate smoke tests, regression tests, etc., into different folders or use naming conventions. You might have folders like smoke-tests/, regression/, etc., but an easier way is to tag tests (discussed later) while keeping a feature-based hierarchy.
Support and utils: Utilize cypress/support/commands.js for custom commands (common actions) and possibly create additional utility modules if needed (e.g. cypress/support/utils.js for helper functions). These are loaded automatically via support/e2e.js (or index.js in older versions) before each test file. You can import additional support files in e2e.js as needed to make functions available globally.
Fixtures: Store any static test data in JSON or other files under cypress/fixtures. This might include sample data for forms, response stubs, or any repeatable dataset your tests use. Fixtures can be loaded with cy.fixture() in tests to keep the test code clean of large data blobs.
By default, Cypress will look in the cypress/e2e folder for spec files and in cypress/fixtures for fixtures, unless you change these in cypress.config.js. It's recommended to stick to the default structure unless a strong reason otherwise​
DOCS.CYPRESS.IO
​
DOCS.CYPRESS.IO
, so that new contributors or tools (like AI agents) can easily navigate the standardized layout.
Test Data Management
Managing test data is crucial for reliable E2E tests. Test data refers to the application state or inputs your tests rely on, which might include database records, API responses, form input values, etc.
Use Fixtures for Static Data: If your test needs a known set of input values or an expected response payload, use fixture files. Cypress can load a fixture (from cypress/fixtures) via cy.fixture('filename.json') and use that data in a test. For example, you might store a sample user profile in user.json and then in your test do:
js
Copy
Edit
cy.fixture('user.json').then((user) => {
  cy.get('[data-cy=name]').type(user.name);
  cy.get('[data-cy=email]').type(user.email);
});
This keeps test data separate from test logic, making it easier to update and reuse.
Consistent Test State: Ensure each test starts with a known, clean state. Cypress by default resets the browser state between tests – clearing cookies, local storage, etc. – to enforce isolation​
DOCS.CYPRESS.IO
. However, if your application relies on external state (like a database or server), you must handle that. For example, before each test (or suite), you might reset the database to a known state (see Test Hooks below for using beforeEach to do this). The Cypress Best Practices guide notes that manual cleanup is usually only needed for external state; the test runner automatically clears the state of the application under test between tests​
DOCS.CYPRESS.IO
.
Seeding and Fixtures for External Data: For apps with a backend, consider writing a Cypress task or using API calls to set up data. A common pattern is to create a Cypress task (in Node) that resets or seeds the database with test data, then call cy.task('db:seed') at the start of relevant tests. For instance, the Cypress Real World App uses a db:seed task in a beforeEach hook to reset the database and ensure deterministic test state​
DOCS.CYPRESS.IO
. In our basic web app scenario (no database), this might not apply, but the concept is: each test should know exactly what data exists at the start, and ideally create or reset it as part of test setup. This avoids tests influencing each other.
Avoid Hard-Coding Data in Tests: Instead of duplicating the same strings or numbers in multiple tests, consider defining them in one place (fixture or constants). This follows the DRY principle (Don't Repeat Yourself) and makes maintenance easier. For example, if multiple tests use the same admin username, store it in a fixture or an environment variable rather than typing it in every test.
Cleaning Up After Tests: In general, you shouldn’t need to explicitly clean up browser state (cookies/localStorage) thanks to Cypress’s isolation. However, if your test creates persistent data on a server (like creating a user via an API call), you might clean that up in an after hook or via another task. Alternatively, design tests to reuse or reset that data on the next run (e.g., reuse the same test user account for login tests to avoid creating many new users).
By thoughtfully managing test data, you ensure that tests remain independent and reliable. A test should set up the data it needs (directly or via API/tasks) and not rely on leftovers from a previous test.
Selecting Elements and Accessibility Considerations
Selecting DOM elements is a core part of writing Cypress tests (e.g., clicking buttons, typing into fields, verifying text). Using resilient selectors is critical to avoid flaky tests. Follow these guidelines:
Prefer data-* attributes for selectors: Cypress recommends adding custom attributes to your HTML (like data-cy, data-test, or data-testid) to use as hooks for your tests​
DOCS.CYPRESS.IO
​
DOCS.CYPRESS.IO
. These attributes are not used by the app’s functionality or styling, so they are less likely to change. For example:
html
Copy
Edit
<button data-cy="submit">Submit</button>
In the test, you can reliably select this with cy.get('[data-cy="submit"]').click(). This approach is considered robust against changes, because even if the button’s classes, text, or position change, the test will still find it via the data-cy attribute​
DOCS.CYPRESS.IO
. In fact, Cypress documentation ranks a data-cy selector as the most stable ("Always Best") compared to other methods​
DOCS.CYPRESS.IO
.
Avoid brittle selectors: Do not rely on selectors that could easily break:
CSS classes or IDs that are auto-generated or subject to change: e.g., classes from UI libraries (.btn.large.primary) or dynamically generated IDs. These may change when the UI is updated or due to CSS changes​
DOCS.CYPRESS.IO
. If you target an element by class like .btn-large, a styling change could break the test​
DOCS.CYPRESS.IO
.
Text content selectors (using cy.contains): While cy.contains('Submit') can be useful, it ties the test to the exact text. If the text changes (e.g., "Submit" to "Save"), the test will fail unnecessarily​
DOCS.CYPRESS.IO
. Use text-based selectors only when the text is an essential part of what you’re verifying (for example, you want the test to fail if the wording changes)​
DOCS.CYPRESS.IO
. Otherwise, prefer a data attribute.
Selector chains that depend on DOM structure: e.g., cy.get('ul > li:nth-child(2) > .btn'). These are very brittle; any HTML restructuring can break them. Instead, add a data attribute to the specific element you need, or find it by a stable ancestor + data attribute.
Accessibility and semantic selectors: When possible, it’s good to align tests with accessibility hooks. For example, using cy.findByRole('button', { name: /submit/i }) from the Cypress Testing Library (if included) to find a button by its accessible name. This ensures your app’s accessibility features are intact (which benefits users with assistive tech). However, using the Testing Library is optional – you can achieve a lot with data-cy attributes. The Cypress team encourages testing what the user sees or an element’s role when it’s important to your test expectations​
DOCS.CYPRESS.IO
​
DOCS.CYPRESS.IO
, but these approaches do not replace dedicated accessibility testing.
Uniqueness: Ensure that the selector you use is intended to match a single element (or the specific set of elements you want). If you have multiple elements with the same data-cy, refine your selection by scoping (e.g., cy.get('[data-cy="user-card"]').first() for the first user card). Better yet, if they are truly the same role, perhaps they need a distinguishing attribute or text that you can use in the selector.
Selector Playground: Use Cypress’s built-in Selector Playground to help generate selectors. By default, it will suggest selectors giving preference to data-cy, data-test, etc.​
DOCS.CYPRESS.IO
. This can be a quick way to grab a robust selector if you’re inspecting your app in the Cypress Test Runner.
In summary, define stable hooks in your HTML for testing. This might involve adding data-cy attributes to key elements. This not only makes your tests stable and easy to read, but also signals to others that those attributes are used in tests (so they should not be removed arbitrarily).
Using Hooks: before, beforeEach, afterEach, after
Cypress supports Mocha test hooks that help set up preconditions or clean up after tests:
before(): Runs once before all tests in a describe block. Use this for one-time setup. For instance, if all tests in the suite require a user to be logged in, you might do a login sequence here (if you intend to log in once for all tests). However, note that with Cypress’s test isolation, state is reset between tests unless you deliberately preserve it. So before is mainly useful for expensive operations that you want to do once and not reset afterward. One example could be seeding a database with a large dataset once before the suite runs (to save time).
beforeEach(): Runs before each test in the block. This is the most common hook for E2E tests. Use beforeEach to establish a consistent starting state for each test. Typical uses:
Navigating to a specific page or route at the start of each test (cy.visit()).
Resetting or seeding application state (e.g., calling cy.task('db:seed') to reset a database, or clearing localStorage if needed).
Setting up common intercepts or mocks for each test (for example, stubbing network responses that will be used in all tests of the suite).
By using beforeEach, you ensure each test starts fresh, which improves test isolation and reliability​
DOCS.CYPRESS.IO
. For example:
js
Copy
Edit
describe('Contact Form', () => {
  beforeEach(() => {
    // Assume the app has a baseUrl set, so "/" goes to the home page
    cy.visit('/contact');
    // Assume we want to start each test with no prior form data:
    cy.clearLocalStorage();
  });
  
  it('submits successfully with valid data', () => { ... });
  it('shows validation errors on invalid input', () => { ... });
});
In this snippet, each test navigates to the Contact page and clears local storage beforehand, so they don't interfere with each other.
afterEach(): Runs after each test. This is less commonly needed in Cypress because of automatic state cleanup. But you might use afterEach for tasks like:
Taking additional screenshots on test failure (though Cypress can auto-capture screenshots on failure).
Logging extra information or resetting something in the application that isn’t covered by Cypress’s automatic reset.
Clean up side-effects if a test leaves persistent changes on an external system (e.g., deleting records created during the test via API).
Generally, try to design tests such that explicit cleanup in afterEach isn’t necessary (tests should clean up via the app's normal behavior or be isolated). A common pattern is to use afterEach to log out a user if the app retains session between tests when running in open mode (though in headless runs Cypress will reset cookies/session storage by default).
after(): Runs once after all tests in the suite. Use this for tearing down conditions set in before. For example, if before() set up a large dataset or logged in a user that persists across tests (using cy.session() or cookies), then after() could log out or clear the data. In many cases, you may not need an after() at all. If you started a server or some external resource in before, you might stop it in after.
Best Practices for Hooks: Keep hook code minimal and focused on setup/cleanup, not on assertions. Do not put test assertions in before or beforeEach – if they fail, it might prevent tests from running. Use hooks strictly to prepare or reset state, not to verify behavior (verifications belong in the tests themselves). Also, be mindful that beforeEach hooks from all suites execute when using "Run all specs" in the GUI (concatenating hooks from different files)​
FILIPHRIC.COM
, though in normal cypress run each spec runs independently. Typically, each spec file has its own hooks and you don’t combine specs in one run unless explicitly aggregating.
Custom Commands and Utilities
Cypress allows the creation of custom commands – essentially your own high-level commands built on top of Cypress’s API. These are extremely useful for abstracting repetitive sequences and implementing the DRY principle. Custom Commands (Cypress.Commands.add): In the cypress/support/commands.js file, you can add new commands. For example, if many tests require logging in, you could create a cy.login() command:
js
Copy
Edit
// cypress/support/commands.js
Cypress.Commands.add('login', (email, password) => {
  cy.visit('/login');
  cy.get('[data-cy="login-email"]').type(email);
  cy.get('[data-cy="login-password"]').type(password);
  cy.get('[data-cy="login-submit"]').click();
});
Once defined, this command can be used in any test:
js
Copy
Edit
// In a test spec:
cy.login('[email protected]', 'secret123');
// after login, proceed with test actions that assume an authenticated user
Using custom commands improves readability (“what” the test is doing, e.g., cy.login(), instead of “how”) and promotes reuse​
BROWSERSTACK.COM
. Commands can also encapsulate complex logic (like handling API calls, dealing with multiple elements, etc.) behind a simple interface. Good candidates for custom commands include: logging in/out, filling out common form sequences, setting up application state via API calls, or selecting elements by data attribute (you can write a helper like cy.getBySel('selector') as shown below). For example, to streamline element selection by data attribute (as recommended above), you might add:
js
Copy
Edit
Cypress.Commands.add('getBySel', (selector, ...args) => {
  return cy.get(`[data-cy="${selector}"]`, ...args);
});
Now cy.getBySel('submit') will fetch [data-cy="submit"]. This approach is demonstrated in Cypress’s Real World App, which defines getBySel and getBySelLike for targeting elements by data-test attributes​
DOCS.CYPRESS.IO
​
DOCS.CYPRESS.IO
. Utilities and Helper Functions: Not everything must be a Cypress command. If you have pure utility functions (e.g., to generate random test data, format a string, etc.), you can write them as regular JavaScript functions in separate files (like cypress/support/utils.js or under a cypress/utils/ folder) and import as needed. The key difference: custom commands (cy.someCommand) are part of Cypress’s command chain and have built-in async handling and logging in the Cypress UI, whereas a utility function is just a helper that might return a value or perform a calculation. Use each for what it’s best at:
Use custom commands when you want to perform a sequence of Cypress actions or assertions that you’ll reuse in tests.
Use plain utility functions for logic that doesn’t involve Cypress commands (or to prepare inputs for Cypress commands).
Avoiding Conflicts: If you create custom commands, be careful not to name them the same as existing Cypress commands. For example, don’t create a command called visit or click. Use unique names that make sense in your domain (like login, addTodo, getBySel). Using TypeScript for commands: If your project is in TS, you can add type definitions so that your custom commands are recognized. This involves adding to the Cypress namespace in a d.ts file. (Since this is a basic guide, we won't cover the details, but it’s something to consider for large projects.)
Writing Good Test Scenarios (Keep It User-Focused)
When designing test cases, focus on user-centric behavior and outcomes rather than internal implementation. Each test should ideally cover a specific user story or acceptance criterion (e.g., “user can update their profile picture”). This keeps tests understandable and aligned with business value​
BROWSERSTACK.COM
. Avoid writing E2E tests for things that a lower-level test should catch (like verifying a utility function’s output) – those belong in unit tests. Each test should generally follow the pattern: setup state, perform actions, assert outcomes:
Setup: Prepare the app state needed (this might be already handled by beforeEach or just navigating to the right page, maybe seeding data).
Action: Simulate the user’s action (click, type, submit, etc.).
Assertion: Check that the expected result occurred (the user is navigated to dashboard, a success message appears, data is displayed correctly, etc.).
Common Cypress Test Design Patterns
In larger test suites, certain patterns help manage complexity and avoid repetition. Here we discuss a few common ones: Page Object Model, the DRY principle in tests, ensuring test isolation, and strategies to handle flaky tests.
Page Object Model (POM)
What is POM? The Page Object Model is a design pattern where you create separate classes or modules representing pages or components of your application. Each page object contains locators (selectors) and methods that encapsulate interactions with that page. The tests then use these page objects instead of directly using Cypress commands with selectors. For example, a simple Page Object for a login page might be defined as a class or object with methods like:
js
Copy
Edit
// cypress/pages/LoginPage.js
export class LoginPage {
  navigate() { cy.visit('/login'); }
  enterEmail(email) { cy.get('[data-cy="login-email"]').type(email); }
  enterPassword(password) { cy.get('[data-cy="login-password"]').type(password); }
  submit() { cy.get('[data-cy="login-submit"]').click(); }
}
In a test, you would use this as:
js
Copy
Edit
import { LoginPage } from '../pages/LoginPage';
const loginPage = new LoginPage();

describe('Login', () => {
  it('allows a user to log in with valid credentials', () => {
    loginPage.navigate();
    loginPage.enterEmail('[email protected]');
    loginPage.enterPassword('secret123');
    loginPage.submit();
    // assertions for successful login...
  });
});
The advantage is that the test reads very clearly, and if the login page changes (e.g., a selector changes), you update it in one place (the page object). This pattern improves maintainability and readability by separating the "what" (intent) from the "how" (implementation details)​
THOUGHTWORKS.COM
​
THOUGHTWORKS.COM
. However, there are trade-offs to consider​
THOUGHTWORKS.COM
:
Initial overhead: Creating and maintaining page object classes requires effort, especially as the application grows. You need to ensure the page objects are kept up-to-date with the app.
Test speed: If every interaction must go through the UI as defined in page objects, you might end up re-running the same sequence many times (for example, a POM might always navigate through the UI menu to get to a page, whereas a test without POM might directly visit a URL or use an API to set state faster). That said, you can design page objects smartly to allow some shortcuts if needed.
Abstraction vs. clarity: Over-abstraction can sometimes make it harder to see what the test is actually doing (you have to jump to the page object to see the details). Make sure your page object methods are clearly named and not doing overly complex things hidden from the tester.
When to use POM: POM is most beneficial in large projects or teams where many tests will interact with the same pages, and consistency is important. It provides a layer of indirection that can ease maintenance if used well​
THOUGHTWORKS.COM
. For a smaller basic web app, POM might be overkill – simpler patterns like custom commands or just well-structured tests could suffice. But it’s still good to be familiar with POM in case your testing needs grow. Best Practices if using POM:
Each page object should represent a single page or component. It should expose actions that a user can do on that page (methods) and perhaps getters for important elements or verification points.
Keep logic out of page objects; they should mostly be calling Cypress commands, not making decisions. The test should decide what to do, the page object just does it.
You can store page objects in a cypress/pages/ directory (or similar). Some people put them under cypress/support as well. As long as they can be imported in tests, structure is up to you.
Still use data attributes in your selectors inside page objects. POM is about organizing your selectors, not an excuse to use brittle selectors.
Alternatives to POM: One alternative is using App Actions or simply custom commands for common flows​
THOUGHTWORKS.COM
​
THOUGHTWORKS.COM
. Cypress, since it has access to your application, can sometimes bypass the UI to set state (for example, directly calling application code or using the API). Another approach is a hybrid: use page objects for complex components, but also leverage custom commands for very frequent tasks (like logging in). Thoughtworks suggests using POM for large, complex projects, but using simpler app action commands for smaller projects to avoid unnecessary complexity​
THOUGHTWORKS.COM
. Ultimately, choose what makes tests more maintainable for your context.
DRY Principle in Tests (Don't Repeat Yourself)
Even without formal POM, you should apply the DRY principle to your test code:
Reuse common setup: If multiple tests require the same sequence of actions to reach a point, consider moving that sequence to a beforeEach or a custom command. For example, if 5 tests all need to create a new item via UI steps, that’s a candidate for a cy.createItem(name) command instead of copying those steps in each test.
Avoid magic numbers/strings: If a value is used in several places (like the name of a CSS selector or a particular text string), define it once. You can use constants, environment variables, or fixtures.
Parametrize tests when needed: If you find yourself writing very similar tests that only differ in some inputs and expected outputs, you might use a data-driven approach. Cypress doesn’t have a built-in data-driven test feature, but you can simulate it by looping over an array of test cases in a single it or by using it within a loop (be careful to not create dynamic test names that are too long). Alternatively, use a helper function that encapsulates the test logic and call that function with different data from multiple it blocks.
However, avoid over-DRYing at the expense of clarity. Each test should still be readable on its own. If you abstract too much (for example, a single helper that does a whole user journey with many steps), someone reading the test might not understand what's happening without jumping between multiple functions. Strive for a balance: eliminate obvious repetition, but keep tests straightforward.
Test Isolation and State Management
Test isolation means each test can run independently of others. In Cypress, test isolation is enforced by clearing the state between tests​
DOCS.CYPRESS.IO
 (new browser context for each it by default). Nevertheless, you should design your tests assuming they might run alone or in any order:
No Inter-Test Dependencies: Do not make one test rely on another test’s outcome. For instance, avoid a situation where Test B assumes that Test A has created a user or logged in already. Instead, if Test B needs a logged-in user, it should perform a login (or use a login command or session) itself.
Use beforeEach to reset state: As mentioned, leverage hooks to ensure starting conditions. If the app has user sessions, decide whether each test logs in anew (recommended for true isolation, possibly with cy.session() for performance) or if you have a global login once (which breaks strict isolation and is not recommended unless tests are read-only after login).
Cypress cy.session() for login optimizations: Cypress has a feature cy.session() that can cache and restore cookies/localStorage for you, so you can avoid logging in through the UI for every test while still isolating the authenticated state. This is an advanced optimization – initially, focus on correctness by doing a fresh login or state setup each time, then consider using cy.session() if the login process is slow and used by many tests.
Shared Fixtures/State: If using fixtures or external resources, ensure they are static or reset for each test run. If two tests modify the same data on a server, they could conflict. Either run such tests serially (not ideal), or better, make them operate on separate data (different test user accounts, etc.) or cleanup after themselves.
Cypress’s automatic isolation saves you from many common issues (like leftover cookies or DOM state). In fact, the docs warn that you usually don’t need to manually log out or reset the client state in afterEach – doing so might be redundant​
DOCS.CYPRESS.IO
. Focus your isolation concerns on things outside Cypress’s control (server state, etc.).
Dealing with Flaky Tests
Flaky tests are tests that sometimes pass and sometimes fail without changes to the code. They undermine trust in the test suite​
TRUNK.IO
. Common causes of flakiness in Cypress tests and how to address them:
Timing issues (async waits): The app might not have finished doing something by the time the test tries to interact or assert. For example, using a fixed cy.wait(5000) to wait for an element that usually appears after 3 seconds – this might pass sometimes and fail other times if 5 seconds isn’t always enough​
TRUNK.IO
​
TRUNK.IO
. Solution: Rely on Cypress’s built-in retry and assertions. Instead of fixed waits, use commands like cy.get(selector).should('be.visible') which will retry until the element is visible (up to the default timeout). Or, if waiting for an XHR/request, use cy.intercept() to stub or spy the call, then cy.wait('@alias') for it to complete. Only use cy.wait() with a static time as a last resort (and if you do, document why, and prefer adjusting timeouts or polling for a condition).
Element not attached or detached errors: This can happen if, for example, you attempt to click an element that is in the process of animating or being removed. Use { force: true } sparingly if needed to click hidden elements, but usually, adding an assertion that the element is visible/enabled before clicking is better.
Dependent tests or order issues: If tests aren’t isolated, one test’s failure could cascade or its leftover state could break another, creating flakiness. The solution is the isolation practices discussed above (each test ensures its own state).
External factors: Sometimes tests fail due to external services (e.g., a third-party API is slow or returns different data). For consistency, you might stub external calls using cy.intercept() so your tests don’t rely on real external systems. This ensures predictable responses. If you want to test the integration with external service, that might be a separate test, but your primary E2E tests should focus on your app’s behavior, not the volatility of external APIs.
Strategies to improve stability:
Use should and assertions to wait for conditions: For example, if clicking a save button triggers a save, and a success message appears, do cy.get('[data-cy=success-message]').should('be.visible') instead of a blind delay. Cypress will keep checking for the message for its default timeout (which is 4 seconds by default for most commands, but can be configured).
Increase timeouts for known slow operations: If a particular action consistently takes, say, 10 seconds (maybe a report generation), you can do cy.get(selector, { timeout: 15000 }) to override the timeout for that command, or set the default command timeout in cypress.config.js for all commands. But use this carefully; if things are that slow, consider whether the E2E test can avoid waiting (maybe stub the response).
Enable retries for tests: Cypress supports test retries (configurable in cypress.config.js or via CLI) which will re-run a failed test a certain number of times. This can mask flaky tests issues by eventually passing, but it helps avoid false negatives in CI due to one-off timing issues. Nonetheless, treat retries as a safety net; you should still fix the root cause of flakiness.
Run tests in CI as in local: Flakiness often appears in CI due to differences (headless mode, slower resources). Make sure you run tests in headless mode locally occasionally, and consider running the CI with the same browser you test locally. Chrome vs Electron differences can sometimes be an issue (though rare). If a test is flaky only in one environment, investigate differences (timing, screen size, etc.).
Use consistent data: If tests rely on certain data existing (like a specific user or record), ensure that data is injected or created fresh in the test. Flakiness can occur if one run deletes a record and the next run doesn't find it. This again comes down to test data management.
Example of a Flaky vs Stable approach: Flaky approach (bad):
js
Copy
Edit
cy.get('[data-cy=open-form]').click();
cy.wait(5000); // hoping the form loads within 5 seconds
cy.get('[data-cy=submit-button]').click();
This might pass locally, but fail if the form takes longer to load on CI​
TRUNK.IO
. It’s an arbitrary wait. Improved approach:
js
Copy
Edit
cy.get('[data-cy=open-form]').click();
cy.get('[data-cy=form-container]').should('be.visible'); // wait until form container is visible
cy.get('[data-cy=submit-button]').click();
Here, the test will wait up to the default timeout for the form container to appear, which is more robust. If needed, you could also do cy.intercept('GET', '/formData').as('loadFormData'); cy.get('[data-cy=open-form]').click(); cy.wait('@loadFormData'); ... to wait for a network call. In summary, always think: If this test failed, could it be because the app wasn't ready or some state carried over? If yes, add appropriate waiting or state reset. Flaky tests can be detected by running tests multiple times; Cypress even has a feature in its Dashboard to spot flaky tests by tracking retry passes​
DOCS.CYPRESS.IO
.
Examples of Good vs. Bad Test Practices
This section highlights some concrete examples of what to do and what to avoid in Cypress tests.
Selecting Elements: Good vs Bad
Good: Use data attribute selectors
js
Copy
Edit
// Good: stable selector
cy.get('[data-cy="nav-login"]').click();
This targets a specific element meant for testing. It’s clear and robust.
Bad: Use complex CSS/XPath selectors or text that might change
js
Copy
Edit
// Bad: too generic and tied to UI structure
cy.get('nav ul li:nth-child(3) > a').click();

// Bad: relies on link text that might change
cy.contains('Login').click();
The first selector is brittle (if the navigation structure changes, it breaks). The second might break if the button text changes or if there's another element with "Login". Instead, a data-cy="nav-login" on the anchor would be better.
Test Structure and Assertions: Good vs Bad
Good: One logical assertion per test (or per scenario).
Each test should focus on a single feature or user story. It can contain multiple assertions, but they should all relate to the one scenario being tested. For example:
js
Copy
Edit
it('allows the user to add an item to the todo list', () => {
  cy.get('[data-cy=new-todo]').type('Buy milk{enter}');
  cy.get('[data-cy=todo-item]').should('have.length', 1);
  cy.get('[data-cy=todo-item]').first().should('contain.text', 'Buy milk');
});
This test adds one item and then asserts two things about the outcome (the list length and the text). Those assertions together verify the scenario "adding an item".
Bad: Asserting unrelated things in one test, or doing too much.
js
Copy
Edit
it('tests many things at once', () => {
  // 1. logs in
  // 2. creates a post
  // 3. edits the profile
  // 4. deletes the post
  // 5. logs out
  // and then asserts multiple things across all steps
});
This is more like a full script than a test – if it fails in the middle, you don't know which functionality broke. It's better to break this into multiple tests (login flow, create post, edit profile, delete post) unless the user story truly is "an admin user can go through the entire lifecycle in one session" and you want to test the combined flow. Even then, consider if a long flow can be flaky; sometimes it's better to test smaller chunks.
Bad: Tests that depend on each other.
For example, Test B assumes Test A ran first to create some data. This is an anti-pattern because if you run Test B alone, it fails. Always initialize data within the test or its hooks.
Good: Use beforeEach to avoid repetitive setup in each test, but ensure the action being tested is in the test itself.
js
Copy
Edit
describe('Profile Page', () => {
  beforeEach(() => {
    cy.login('user@example.com', 'password'); // custom command to log in
    cy.visit('/profile');
  });
  it('shows the correct profile information', () => {
    cy.get('[data-cy=profile-name]').should('contain', 'John Doe');
    cy.get('[data-cy=profile-email]').should('contain', 'user@example.com');
  });
  it('allows the user to update their profile picture', () => {
    // ... test for updating picture
  });
});
Here the login and navigation is done for each test. The tests then focus on verifying content and actions on the profile page. They don't need to worry about how to log in or get to the page.
Bad: Duplicating the same sequence in every test when it could be in a hook or command.
If you see five tests all starting with the same few lines (like logging in), refactor that out.
Using Cypress Commands: Good vs Bad
Good: Leverage Cypress’s commands and assertions properly. For example, use .should() to make Cypress retry until a condition is met, instead of manual waits. Combine commands with aliases and cy.wait for network calls:
js
Copy
Edit
cy.intercept('GET', '/api/items').as('getItems');
cy.get('[data-cy=refresh]').click();
cy.wait('@getItems').its('response.statusCode').should('eq', 200);
cy.get('[data-cy=item]').should('have.length.greaterThan', 0);
This ensures the UI waits for data load and then checks the results.
Bad: Arbitrary cy.wait() or setTimeout usage:
js
Copy
Edit
cy.get('[data-cy=refresh]').click();
cy.wait(3000); // hoping items load within 3 seconds
cy.get('[data-cy=item]').should('have.length', 5);
If the items take longer, this fails; if they load faster, you wasted time. Always synchronize with app events or use should assertions.
Bad: Trying to capture return values from Cypress commands incorrectly:
js
Copy
Edit
const text = cy.get('[data-cy=welcome]').text(); // WRONG: cy.get() doesn't return text directly
expect(text).to.equal('Welcome'); // This won't work as expected
This is a common mistake by newcomers. Instead, do:
js
Copy
Edit
cy.get('[data-cy=welcome]').should('have.text', 'Welcome');
// or
cy.get('[data-cy=welcome]').then($el => {
  expect($el.text()).to.equal('Welcome');
});
Remember that almost all Cypress commands are asynchronous and yield their subject to the next command; you cannot assign them to variables directly in the same context​
DOCS.CYPRESS.IO
​
DOCS.CYPRESS.IO
.
Real-World Example Wrap-up
To illustrate a cohesive example, below is a sample test suite with good practices applied for a basic "Todo App":
js
Copy
Edit
// cypress/e2e/todo.cy.js
describe('Todo Application', () => {
  beforeEach(() => {
    cy.visit('/'); // navigate to the home page of the app
    cy.get('[data-cy=clear-demo-data]').click(); // custom step: assume the app has a button to reset to a clean state for demo/testing
  });

  it('should allow adding a new todo item', () => {
    cy.get('[data-cy=new-todo-input]').type('Write Cypress guide{enter}');
    cy.get('[data-cy=todo-item]').should('have.length', 1);
    cy.get('[data-cy=todo-item]').first().should('contain.text', 'Write Cypress guide');
  });

  it('should allow marking a todo as completed', () => {
    // Setup: ensure there's an item to complete
    cy.get('[data-cy=new-todo-input]').type('Buy milk{enter}');
    // Action: mark it complete
    cy.get('[data-cy=todo-item]').first().find('[data-cy=toggle-complete]').check();
    // Assertion: item has 'completed' class or state
    cy.get('[data-cy=todo-item]').first().should('have.class', 'completed');
  });

  it('should filter to show only completed todos', () => {
    // Setup multiple items and complete one
    cy.get('[data-cy=new-todo-input]').type('Task A{enter}');
    cy.get('[data-cy=new-todo-input]').type('Task B{enter}');
    cy.get('[data-cy=todo-item]').last().find('[data-cy=toggle-complete]').check();
    // Action: apply filter "Completed"
    cy.get('[data-cy=filter-completed]').click();
    // Assertion: only one item is visible and it is completed Task B
    cy.get('[data-cy=todo-item]').should('have.length', 1);
    cy.get('[data-cy=todo-item]').first().should('contain.text', 'Task B')
      .and('have.class', 'completed');
  });
});
In this example:
We use data-cy selectors for all interactions.
Each test is independent; the beforeEach clears existing data.
No arbitrary waits; assertions naturally wait for conditions.
Test names clearly state the feature being verified.
Suggested Project Structure for Cypress Tests
Organizing tests well helps both humans and automated tools (like AI agents) to navigate the test suite. Here’s a suggested structure for a basic web application’s Cypress tests:
bash
Copy
Edit
cypress/
├── e2e/
│   ├── common/                # (optional) common flows or cross-feature tests
│   ├── home.cy.js             # tests for home page features
│   ├── login.cy.js            # tests for login page
│   ├── dashboard.cy.js        # tests for dashboard page
│   ├── settings/             # folder for settings-related specs
│   │    ├── profile.cy.js     # profile settings tests
│   │    └── account.cy.js     # account settings tests
│   └── ... (other feature spec files)
├── fixtures/
│   ├── example.json           # example fixture (scaffolded)
│   ├── users.json             # test user data
│   └── testData.json          # any other test data
├── support/
│   ├── commands.js            # custom Cypress commands
│   ├── e2e.js                 # support file loaded before e2e tests (can import others)
│   └── utils.js               # (optional) shared utility functions
└── pages/                     # (optional) Page Object Model classes if using POM
    ├── LoginPage.js
    └── ... other page objects
A few notes on this structure:
The e2e folder contains spec files. You can further group them into subfolders by feature area (as shown with a settings/ subfolder). Cypress by default will find all *.cy.* (or *.spec.*) files in the e2e directory tree.
The fixtures folder holds test data files. Name fixtures clearly (e.g., users.json, productList.json) for what they contain.
The support folder contains code that is loaded automatically. The e2e.js (or index.js in older Cypress) is executed before every spec file – a good place to import custom commands or set global behavior (like turning off uncaught exception handling if needed, or configuring plugins).
If using Page Objects, a separate pages directory is a logical place to store them. This keeps them separate from the Cypress-specific support files, and you can import them in tests as needed.
Keep test code versioned with the app code. This structure lives alongside your application code in source control (it is common to have a separate top-level folder for tests like cypress/). Make sure to include Cypress in your devDependencies so that the tests can run in CI.
This structure is just a template – adapt it as the application grows. The goal is to make it intuitive: one should easily find the tests for a given feature by looking at folder and file names. Consistency is key.
Tagging and Test Categorization Conventions
In larger test suites, you may want to categorize or tag tests for selective execution. For instance, you might tag some tests as "smoke" tests (a small subset that runs on every commit) versus the full regression suite that runs nightly or on release. While Cypress by itself doesn’t have a built-in tagging mechanism in Mocha, you can achieve it through naming conventions or plugins:
Via test titles (naming convention): One simple method is to include a keyword in the describe or it title and use Cypress’s --grep option (which leverages Mocha’s grep functionality) to run only matching tests. For example, if you include “[smoke]” in the title:
js
Copy
Edit
it('should load dashboard [smoke]', () => { ... });
Then running cypress run --grep "smoke" will execute only tests with “smoke” in their name. This approach is straightforward but tags become part of the test name output.
Using a plugin (cypress-grep or cypress-tags): These plugins provide a more structured way to tag tests. For example, with cypress-tags you can tag tests like:
js
Copy
Edit
describe(['regression', 'user-features'], 'User Profile', () => {
  it(['smoke'], 'allows updating the profile', () => { ... });
  it('does something else', () => { ... });
});
Then use environment variables to include or exclude tags when running:
bash
Copy
Edit
CYPRESS_INCLUDE_TAGS=smoke npx cypress run
This will run only tests tagged with "smoke"​
STACKOVERFLOW.COM
. You can also combine include/exclude for complex filtering​
STACKOVERFLOW.COM
. Similarly, the cypress-grep plugin allows using it('@smoke', ... style tags in titles and filtering by them​
NPMJS.COM
.
Suite-level filtering: Sometimes, you might just split tests by folder as a way to group them (e.g., put critical tests in a smoke/ folder). Then you could run cypress run --spec "cypress/e2e/smoke/*" to run only those. However, using tags is more flexible since a test can have multiple tags (e.g., a test can be both "smoke" and "regression").
Avoid overusing .only: During development, Cypress allows you to append .only to a describe or it to run only that test or suite. This is great for focus, but ensure you remove any .only before committing. A committed .only will cause your CI to run just that test and skip others, potentially letting bugs slip through. Similarly, .skip can exclude tests; use it to temporarily disable flaky tests if needed, but address the underlying issue soon and remove the skip.
Marking flaky or WIP tests: You might tag tests as ['wip'] or ['flaky'] and have your CI exclude those by default (e.g., CYPRESS_EXCLUDE_TAGS=wip,flaky). This way, known problematic tests don't break the main pipeline, but they remain in the codebase for debugging and can be run separately.
For the AI agent perspective, having tags or keywords in test titles can help it decide which tests to run or generate. For example, an AI might decide to run only smoke tests for a quick check. Therefore, clearly label important subsets of tests either via naming or using one of the above plugins. Example Tag Usage:
Suppose we decide on a simple convention using @ in test titles for tags (with the cypress-grep plugin). We could write:
js
Copy
Edit
it('User can reset password @regression @user-settings', () => { ... });
In CI, to run only smoke tests, we might use:
arduino
Copy
Edit
npx cypress run --env grepTags=smoke
And for a full run excluding a long-running set, maybe:
nginx
Copy
Edit
npx cypress run --env grepTags="not @perf"
(to exclude performance-intensive tests tagged @perf). Ultimately, choose a tagging approach that your team will apply consistently. Document the meaning of each tag in the README (e.g., define what "smoke" means in your context, which tests qualify as smoke).
CI/CD Integration Tips
Integrating Cypress tests into Continuous Integration/Continuous Deployment (CI/CD) pipelines ensures your E2E tests run automatically on commits or deployments. Here are guidelines and tips for a smooth CI/CD setup:
Headless Test Execution: In CI, you will typically run cypress run (which runs in headless mode by default using Electron browser, or you can specify --browser chrome for headless Chrome). This means no GUI; tests run and output results to the console. Make sure your tests don’t rely on anything that requires the interactive GUI (they shouldn’t, by design). If you have visual tests or need screenshots, Cypress will still take screenshots and videos in headless mode.
Start the Application Server: Ensure your web application is running (accessible) when tests run. Commonly, you might:
Install dependencies (including Cypress).
Start the web server (e.g., npm start or a test-specific server command). In CI, this needs to be run in the background or as a separate process.
Run Cypress tests (npx cypress run).
You can use utilities like start-server-and-test to start the app and wait for a URL to respond before running tests, to streamline this​
DOCS.CYPRESS.IO
. For example:
pgsql
Copy
Edit
start-server-and-test 'npm start' http://localhost:3000 'cypress run'
Environment Configuration: Use the Cypress configuration or environment variables to differentiate between local and CI if needed. For instance, you might have a baseUrl set to http://localhost:3000 for local and use an environment variable for CI URL if different. Many teams run the same baseUrl in CI (starting a local server in CI), which is simplest. Also consider environment-specific data: e.g., in CI you might want to use a different user account or database. Cypress allows setting environment variables via cypress.config.js or the CLI (--env key=value).
Test Reports: By default, Cypress prints test results to stdout. If you want to integrate with CI test reporting (like Jenkins or CircleCI test reports), consider using a Mocha reporter that outputs JUnit or JSON results. For example, you can run Cypress with --reporter junit --reporter-options "mochaFile=results/my-test-output.xml" to generate an XML report that CI can parse. You would then archive this file as an artifact in CI.
Screenshots and Videos: Cypress by default will save a screenshot on failure and a video of the whole test run (video can be disabled in config if not wanted). It’s a good practice to store these artifacts when a CI run fails. For example, on GitHub Actions or CircleCI, you can configure the workflow to upload the cypress/screenshots and cypress/videos directories as artifacts if tests fail​
KAILASH-PATHAK.MEDIUM.COM
. This way, developers can download and see what the test saw. In some CI environments, you might always save videos for record-keeping, but keep an eye on storage.
Parallelization: If you have a large suite, you can split tests across multiple CI machines to run faster. Cypress can do parallelization via the Cypress Cloud (formerly Dashboard) if you record tests and use their service. This requires setting up a Cypress project record key and using npx cypress run --record --key <record-key> --parallel. Alternatively, you can implement parallelism by splitting spec files among CI jobs manually (e.g., using circleCI matrix jobs or custom scripting to divide tests). Make sure tests are truly independent if running in parallel (they should be, if isolated). The benefit can be substantial in reducing total test time.
CI Provider Specifics: Each CI (GitHub Actions, GitLab CI, Jenkins, etc.) has its nuances:
Most provide Ubuntu images where Cypress can run. The Cypress team provides Docker images with all dependencies, which can simplify setup (like cypress/base:latest or cypress/included:version images that come with Cypress pre-installed for a given version).
Ensure the CI machine has the needed dependencies (Cypress needs a system with Node and a display server for headless browser; the Cypress binary takes care of the browser via Electron if not using Chrome). On Linux, Cypress uses Xvfb automatically in headless mode, so no special config is usually needed.
If using GitHub Actions, there are official Cypress setup actions that install Cypress and cache it. Similarly, for other providers, consult Cypress docs for any config (the Cypress docs have examples for many CI systems​
DOCS.CYPRESS.IO
​
DOCS.CYPRESS.IO
).
Failure Handling: Set up your CI to fail the build if Cypress tests fail (most CI tools will do this automatically if the cypress run command exits with a non-zero code). Do not ignore failures. It's useful to output the Cypress run command’s exit code and message in the logs.
Running in CD (Deployment) Pipeline: You might run a quick smoke test suite after each deployment to a staging or production environment. In that case, point Cypress’s baseUrl to the deployed URL, and maybe filter tests (via tags) to only run critical ones, to avoid a long run. This ensures the deployment was successful and core flows work.
Integrating with Dashboard (optional): The Cypress Cloud dashboard can store results, allow you to see screenshots/videos per test, and provide insights (like flake detection​
TRUNK.IO
). It's free for open source, paid for private projects (with a decent free tier). Using it is optional, but for large projects it can be quite helpful. If not using it, artifacts and CI logs are your main source of truth for failures.
Notifications: If your CI can send notifications (Slack, email, etc.) on failure, consider piping Cypress results into those. For example, you might configure a Slack message if any E2E test fails, possibly including a link to the artifacts or dashboard for easy debugging.
Summary: Treat Cypress tests as an integral part of your CI/CD. Automate them to run on each push or on a schedule, and make sure to surface their results. This catches regressions early. As a tip from the Cypress team: running Cypress in CI is almost the same as running locally – you install it and run it​
DOCS.CYPRESS.IO
​
DOCS.CYPRESS.IO
. The key differences are making the app available and collecting results. Once set up, you have confidence that any failure in a user flow will be caught before changes go live.
By following this comprehensive guide, you can create a robust suite of Cypress end-to-end tests for your basic web application. These guidelines emphasize maintainability, clarity, and reliability, ensuring that both humans and AI agents can understand and work with your tests effectively. Happy testing!